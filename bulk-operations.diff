diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java
index d6bd4085df6..c85741b41ae 100644
--- a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java
+++ b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/RemoteCacheImpl.java
@@ -41,9 +41,11 @@
 import org.infinispan.client.hotrod.impl.operations.CacheOperationsFactory;
 import org.infinispan.client.hotrod.impl.operations.ClearOperation;
 import org.infinispan.client.hotrod.impl.operations.ClientListenerOperation;
+import org.infinispan.client.hotrod.impl.operations.GetAllOperation;
 import org.infinispan.client.hotrod.impl.operations.GetWithMetadataOperation;
 import org.infinispan.client.hotrod.impl.operations.HotRodOperation;
 import org.infinispan.client.hotrod.impl.operations.PingResponse;
+import org.infinispan.client.hotrod.impl.operations.PutAllOperation;
 import org.infinispan.client.hotrod.impl.operations.RetryAwareCompletionStage;
 import org.infinispan.client.hotrod.impl.protocol.Codec30;
 import org.infinispan.client.hotrod.impl.query.RemoteQueryFactory;
@@ -299,8 +301,7 @@ public CompletableFuture<Void> putAllAsync(Map<? extends K, ? extends V> map, lo
       for (Entry<? extends K, ? extends V> entry : map.entrySet()) {
          byteMap.put(keyToBytes(entry.getKey()), valueToBytes(entry.getValue()));
       }
-      // TODO: need to add the parallel version
-      HotRodOperation<Void> op = operationsFactory.newPutAllOperation(byteMap, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
+      PutAllOperation op = operationsFactory.newPutAllOperation(byteMap, lifespan, lifespanUnit, maxIdleTime, maxIdleTimeUnit);
       return dispatcher.execute(op).toCompletableFuture();
    }
 
@@ -538,7 +539,7 @@ public CompletableFuture<Map<K, V>> getAllAsync(Set<?> keys) {
       for (Object key : keys) {
          byteKeys.add(keyToBytes(key));
       }
-      HotRodOperation<Map<K, V>> op = operationsFactory.newGetAllOperation(byteKeys);
+      GetAllOperation<K, V> op = operationsFactory.newGetAllOperation(byteKeys);
       return dispatcher.execute(op)
             .thenApply(Collections::unmodifiableMap)
             .toCompletableFuture();
diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/CacheOperationsFactory.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/CacheOperationsFactory.java
index 84c892c87e5..8b221f22378 100644
--- a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/CacheOperationsFactory.java
+++ b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/CacheOperationsFactory.java
@@ -137,7 +137,7 @@ public <V, K> HotRodOperation<VersionedOperationResponse<V>> newRemoveIfUnmodifi
       return new RemoveIfUnmodifiedOperation<>(remoteCache, remoteCache.getDataFormat().keyToBytes(key), version);
    }
 
-   public <K, V> HotRodOperation<Map<K,V>> newGetAllOperation(Set<byte[]> byteKeys) {
+   public <K, V> GetAllOperation<K, V> newGetAllOperation(Set<byte[]> byteKeys) {
       return new GetAllOperation<>(remoteCache, byteKeys);
    }
 
diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java
index 9588333e9d2..36f4780c7b8 100644
--- a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java
+++ b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/GetAllOperation.java
@@ -1,8 +1,13 @@
 package org.infinispan.client.hotrod.impl.operations;
 
+import java.net.SocketAddress;
+import java.util.Collection;
 import java.util.HashMap;
+import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collectors;
 
 import org.infinispan.client.hotrod.impl.InternalRemoteCache;
 import org.infinispan.client.hotrod.impl.protocol.Codec;
@@ -18,7 +23,7 @@
  * @author William Burns
  * @since 7.2
  */
-public class GetAllOperation<K, V> extends AbstractCacheOperation<Map<K, V>> {
+public class GetAllOperation<K, V> extends HotRodBulkOperation<Map<K, V>, GetAllOperation<K, V>> {
 
    private Map<K, V> result;
    private int size = -1;
@@ -74,7 +79,25 @@ public short responseOpCode() {
    }
 
    @Override
-   public Object getRoutingObject() {
-      return keys.iterator().next();
+   public Map<SocketAddress, GetAllOperation<K, V>> operations(Function<Object, SocketAddress> mapper) {
+      Map<SocketAddress, Set<byte[]>> split = new HashMap<>();
+      for (byte[] key : keys) {
+         SocketAddress target = mapper.apply(key);
+         Set<byte[]> segment = split.computeIfAbsent(target, ignore -> new HashSet<>());
+         segment.add(key);
+      }
+      return split.entrySet().stream()
+            .collect(Collectors.toMap(Map.Entry::getKey, e -> newInstance(e.getValue())));
+   }
+
+   private GetAllOperation<K, V> newInstance(Set<byte[]> subset) {
+      return new GetAllOperation<>(internalRemoteCache, subset);
+   }
+
+   @Override
+   public void complete(Collection<Map<K, V>> responses) {
+      Map<K, V> reduced = new HashMap<>();
+      responses.forEach(reduced::putAll);
+      complete(reduced);
    }
 }
diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodBulkOperation.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodBulkOperation.java
new file mode 100644
index 00000000000..a555c47651e
--- /dev/null
+++ b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/HotRodBulkOperation.java
@@ -0,0 +1,49 @@
+package org.infinispan.client.hotrod.impl.operations;
+
+import java.net.SocketAddress;
+import java.util.Collection;
+import java.util.Map;
+import java.util.function.Function;
+
+import org.infinispan.client.hotrod.impl.InternalRemoteCache;
+
+/**
+ * An HotRod operation that span across multiple remote nodes concurrently (like getAll / putAll).
+ *
+ * @author Guillaume Darmont / guillaume@dropinocean.com
+ */
+public abstract class HotRodBulkOperation<V, O extends HotRodOperation<V>> extends AbstractCacheOperation<V> {
+
+
+   protected HotRodBulkOperation(InternalRemoteCache<?, ?> internalRemoteCache) {
+      super(internalRemoteCache);
+   }
+
+   /**
+    * Split the operation to target the correct servers.
+    *
+    * <p>
+    * A single bulk operation touches multiple keys. Therefore, it is necessary to segment the operation's key space
+    * in multiple smaller operations, each targeting the correct server who owns the keys. The mapper function
+    * identifies which server owns a key.
+    * </p>
+    *
+    * @param mapper A function that receives a key and identify the server who owns it.
+    * @return A map of the segmented operations. Each entry is the sub-operation and the key is the target server.
+    */
+   public abstract Map<SocketAddress, O> operations(Function<Object, SocketAddress> mapper);
+
+   /**
+    * Reduces all the sub-operation's responses to a single object.
+    *
+    * <p>
+    * After the operation is segmented and redirect to each specific server, this method is responsible for putting
+    * the multiple responses together into a single object and finishing the operation.
+    * </p>
+    *
+    * <b>Warning:</b> implementors <b>must</b> call the {@link #complete(Object)} method after the reduce process.
+    *
+    * @param responses A collection with the responses from all targeted servers.
+    */
+   public abstract void complete(Collection<V> responses);
+}
diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java
index d83c6463201..445031442c1 100644
--- a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java
+++ b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllOperation.java
@@ -1,7 +1,12 @@
 package org.infinispan.client.hotrod.impl.operations;
 
+import java.net.SocketAddress;
+import java.util.Collection;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+import java.util.stream.Collectors;
 
 import org.infinispan.client.hotrod.exceptions.InvalidResponseException;
 import org.infinispan.client.hotrod.impl.InternalRemoteCache;
@@ -13,7 +18,7 @@
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
 
-public class PutAllOperation extends AbstractCacheOperation<Void> {
+public class PutAllOperation extends HotRodBulkOperation<Void, PutAllOperation> {
    protected final Map<byte[], byte[]> map;
    protected final long lifespan;
    private final TimeUnit lifespanTimeUnit;
@@ -61,7 +66,25 @@ public short responseOpCode() {
    }
 
    @Override
-   public Object getRoutingObject() {
-      return map.keySet().iterator().next();
+   public Map<SocketAddress, PutAllOperation> operations(Function<Object, SocketAddress> mapper) {
+      Map<SocketAddress, Map<byte[], byte[]>> split = new HashMap<>();
+
+      for (Map.Entry<byte[], byte[]> entry : map.entrySet()) {
+         SocketAddress target = mapper.apply(entry.getKey());
+         Map<byte[], byte[]> segment = split.computeIfAbsent(target, ignore -> new HashMap<>());
+         segment.put(entry.getKey(), entry.getValue());
+      }
+
+      return split.entrySet().stream()
+            .collect(Collectors.toMap(Map.Entry::getKey, e -> newInstance(e.getValue())));
+   }
+
+   private PutAllOperation newInstance(Map<byte[], byte[]> content) {
+      return new PutAllOperation(internalRemoteCache, content, lifespan, lifespanTimeUnit, maxIdle, maxIdleTimeUnit);
+   }
+
+   @Override
+   public void complete(Collection<Void> responses) {
+      complete((Void) null);
    }
 }
diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java
deleted file mode 100644
index 144ceb0ff5e..00000000000
--- a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/operations/PutAllParallelOperation.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package org.infinispan.client.hotrod.impl.operations;
-
-import org.infinispan.client.hotrod.impl.InternalRemoteCache;
-import org.infinispan.client.hotrod.impl.protocol.Codec;
-import org.infinispan.client.hotrod.impl.transport.netty.HeaderDecoder;
-
-import io.netty.buffer.ByteBuf;
-
-/**
- * TODO: need to implement parallel commands for dispatcher!!
- */
-public class PutAllParallelOperation extends AbstractCacheOperation<Void> {
-   protected PutAllParallelOperation(InternalRemoteCache<?, ?> internalRemoteCache) {
-      super(internalRemoteCache);
-   }
-
-   @Override
-   public Void createResponse(ByteBuf buf, short status, HeaderDecoder decoder, Codec codec, CacheUnmarshaller unmarshaller) {
-      return null;
-   }
-
-   @Override
-   public short requestOpCode() {
-      return PUT_ALL_REQUEST;
-   }
-
-   @Override
-   public short responseOpCode() {
-      return PUT_ALL_RESPONSE;
-   }
-}
diff --git a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/OperationDispatcher.java b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/OperationDispatcher.java
index 91bd22211e7..e3552716276 100644
--- a/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/OperationDispatcher.java
+++ b/client/hotrod-client-new/src/main/java/org/infinispan/client/hotrod/impl/transport/netty/OperationDispatcher.java
@@ -7,6 +7,7 @@
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
@@ -18,6 +19,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.StampedLock;
 import java.util.function.Consumer;
+import java.util.function.Function;
 
 import org.infinispan.client.hotrod.CacheTopologyInfo;
 import org.infinispan.client.hotrod.FailoverRequestBalancingStrategy;
@@ -34,12 +36,14 @@
 import org.infinispan.client.hotrod.impl.consistenthash.ConsistentHash;
 import org.infinispan.client.hotrod.impl.consistenthash.SegmentConsistentHash;
 import org.infinispan.client.hotrod.impl.operations.DelegatingHotRodOperation;
+import org.infinispan.client.hotrod.impl.operations.HotRodBulkOperation;
 import org.infinispan.client.hotrod.impl.operations.HotRodOperation;
 import org.infinispan.client.hotrod.impl.protocol.HotRodConstants;
 import org.infinispan.client.hotrod.impl.topology.CacheInfo;
 import org.infinispan.client.hotrod.impl.topology.ClusterInfo;
 import org.infinispan.client.hotrod.logging.Log;
 import org.infinispan.client.hotrod.logging.LogFactory;
+import org.infinispan.commons.util.concurrent.AggregateCompletionStage;
 import org.infinispan.commons.util.concurrent.CompletionStages;
 
 import io.netty.channel.Channel;
@@ -181,6 +185,44 @@ public <E> CompletionStage<E> execute(HotRodOperation<E> operation) {
       return execute(operation, Set.of());
    }
 
+   public <E, O extends HotRodOperation<E>> CompletionStage<E> execute(HotRodBulkOperation<E, O> operation) {
+      Map<SocketAddress, O> bulk = operation.operations(identifyOperationTarget(operation, Set.of()));
+      Collection<E> collector = Collections.synchronizedList(new ArrayList<>());
+      AggregateCompletionStage<Collection<E>> acs = CompletionStages.aggregateCompletionStage(collector);
+      for (Map.Entry<SocketAddress, O> entry : bulk.entrySet()) {
+         CompletionStage<E> single = executeOnSingleAddress(entry.getValue(), entry.getKey());
+         acs.dependsOn(single.whenComplete((v, t) -> {
+            if (t != null) {
+               for (O o : bulk.values()) {
+                  o.cancel(true);
+               }
+            } else {
+               collector.add(v);
+            }
+         }));
+      }
+
+      acs.freeze().whenComplete((res, t) -> {
+         if (t != null) {
+            operation.completeExceptionally(t);
+         } else {
+            operation.complete(res);
+         }
+      });
+      return operation;
+   }
+
+   private Function<Object, SocketAddress> identifyOperationTarget(HotRodOperation<?> operation, Set<SocketAddress> failedServers) {
+      CacheInfo info = getCacheInfo(operation.getCacheName());
+      if (info != null && info.getConsistentHash() != null) {
+         ConsistentHash ch = info.getConsistentHash();
+         return ch::getServer;
+      }
+
+      FailoverRequestBalancingStrategy frbs = getBalancer(operation.getCacheName());
+      return obj -> frbs.nextServer(failedServers);
+   }
+
    public <E> CompletionStage<E> execute(HotRodOperation<E> operation, Set<SocketAddress> failedServers) {
       Object routingObj = operation.getRoutingObject();
       if (routingObj != null) {
